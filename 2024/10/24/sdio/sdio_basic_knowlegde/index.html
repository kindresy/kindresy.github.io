<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"kindresy.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="sdio eMMc相关知识，包括接口，控制器，总线模型，速率模式，内核初始化过程，hs200模式，tuning方式。">
<meta property="og:type" content="article">
<meta property="og:title" content="SDIO eMMc相关知识总结">
<meta property="og:url" content="https://kindresy.github.io/2024/10/24/sdio/sdio_basic_knowlegde/index.html">
<meta property="og:site_name" content="Coffe Pattern">
<meta property="og:description" content="sdio eMMc相关知识，包括接口，控制器，总线模型，速率模式，内核初始化过程，hs200模式，tuning方式。">
<meta property="og:locale">
<meta property="og:image" content="https://kindresy.github.io/stuff/01db3d8fa2234583802a378998b96274.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/01db3d8fa2234583802a378998b96274.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/9cae3b56b99748d0a75c134ec3c4f509.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/47b106e8b90b4dad93f6939bbac6c780.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/b4e03b93893c48f49090a9b2a4271b54.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/c0e1669badcb4d208ff9aa615829fd7a.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/fa1737d6147844558956ab3ec4eba30b.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/d68bdc47e5ec4fdeb81ecac779428c44.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/3f6cf2f283a046ebb5d141ccf96b30c2.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/16bb965442834c298980dee21e1cdf2b.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/565984fdec74475f8e7497d9fc0f8b73.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/ed61d4b25ced4fd1b4de4608084ea102.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/22927a7b815140e6b5478a3aa28b4ae4.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/7c8281c83c5f4bb3bb28660a0e573c1d.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/ebf3d4221bd94e1792ca39da1305e9b5.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/4236210ed6424bf98ebe9e238cf72d75.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/532c911acf5f40e8b000cb9dbe1046f8.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/e3b279e8189d4ddab70dce91b227f2b9.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/c434d366014a4c8da41d5ec52bfb4b7a.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/0db080155a594dba99230de617a98254.png">
<meta property="og:image" content="https://kindresy.github.io/stuff/9a006ab49fe6469ea3c72e4ada6ec570.png">
<meta property="article:published_time" content="2024-10-24T02:15:16.000Z">
<meta property="article:modified_time" content="2024-10-24T05:02:52.194Z">
<meta property="article:author" content="Luyuan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kindresy.github.io/stuff/01db3d8fa2234583802a378998b96274.png">


<link rel="canonical" href="https://kindresy.github.io/2024/10/24/sdio/sdio_basic_knowlegde/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"https://kindresy.github.io/2024/10/24/sdio/sdio_basic_knowlegde/","path":"2024/10/24/sdio/sdio_basic_knowlegde/","title":"SDIO eMMc相关知识总结"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SDIO eMMc相关知识总结 | Coffe Pattern</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Coffe Pattern</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Linux Kernel Driver</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MMC%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">MMC相关知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#what-is-this"><span class="nav-number">1.1.</span> <span class="nav-text">what is this?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E6%88%90"><span class="nav-number">1.2.</span> <span class="nav-text">组成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.3.</span> <span class="nav-text">接口</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#eMMC%E6%80%BB%E7%BA%BF%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">eMMC总线模型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9F%E7%8E%87%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">速率模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">关键参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%9B%E7%94%B5"><span class="nav-number">3.1.1.</span> <span class="nav-text">供电</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%92%9F"><span class="nav-number">3.1.2.</span> <span class="nav-text">时钟</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DW-MCI%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">DW_MCI驱动的初始化流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DW-MCI-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%8Cmmc%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">DW_MCI 如何配置不同mmc模式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DW-MCI%E9%A9%B1%E5%8A%A8-tune%E8%BF%87%E7%A8%8B"><span class="nav-number">6.</span> <span class="nav-text">DW_MCI驱动 tune过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E7%9A%84tune%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.1.</span> <span class="nav-text">实际的tune实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DW-MCI%E9%A9%B1%E5%8A%A8-%E5%A6%82%E4%BD%95%E5%8F%91%E9%80%81%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%95%B0%E6%8D%AE"><span class="nav-number">7.</span> <span class="nav-text">DW_MCI驱动 如何发送命令与数据</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Luyuan</p>
  <div class="site-description" itemprop="description">ARM/Liunx Kernel/OS/Driver</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://kindresy.github.io/2024/10/24/sdio/sdio_basic_knowlegde/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Luyuan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coffe Pattern">
      <meta itemprop="description" content="ARM/Liunx Kernel/OS/Driver">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="SDIO eMMc相关知识总结 | Coffe Pattern">
      <meta itemprop="description" content="sdio eMMc相关知识，包括接口，控制器，总线模型，速率模式，内核初始化过程，hs200模式，tuning方式。">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SDIO eMMc相关知识总结
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2024-10-24 10:15:16 / Modified: 13:02:52" itemprop="dateCreated datePublished" datetime="2024-10-24T10:15:16+08:00">2024-10-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/sdio/" itemprop="url" rel="index"><span itemprop="name">sdio</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

            <div class="post-description">sdio eMMc相关知识，包括接口，控制器，总线模型，速率模式，内核初始化过程，hs200模式，tuning方式。</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="MMC相关知识"><a href="#MMC相关知识" class="headerlink" title="MMC相关知识"></a>MMC相关知识</h1><h2 id="what-is-this"><a href="#what-is-this" class="headerlink" title="what is this?"></a>what is this?</h2><p>eMMC是embedded MultiMediaCard的简称，即嵌入式多媒体卡,是一种闪存卡的标准，它定义了基于嵌入式多媒体卡的存储系统的物理架构和访问接口及协议，具体由电子设备工程联合委员会<strong>JEDEC</strong>订立和发布。它是对MMC的一个拓展，具有体积小，功耗低，容量大等优点，非常适合用作智能手机、平板电脑、移动互联网设备等消费类电子设备的存储介质。</p>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>以三星的KLM8G1GETF-B041为例：<br>由nand flash(闪存)，NAND I&#x2F;O Block(闪存控制芯片)，MMC I&#x2F;O Block组成(标准接口封装)<br><img src="/../../stuff/01db3d8fa2234583802a378998b96274.png" alt="在这里插入图片描述"><br>eMMC则在其内部集成了 Flash Controller，包括了协议、擦写均衡、坏块管理、ECC校验、电源管理、时钟管理、数据存取等功能。相比于直接将NAND Flash接入到Host 端，eMMC屏蔽了 NAND Flash 的物理特性，可以减少 Host 端软件的复杂度，让 Host 端专注于上层业务，省去对 NAND Flash 进行特殊的处理。同时，eMMC通过使用Cache、Memory Array 等技术，在读写性能上也比 NAND Flash要好很多。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>eMMC接口主要实现将eMMC接入到Host的MMC总线上，与Host进行通信，实现eMMC的协议逻辑。<br>eMMC接口与Host之间的连接如下图：<br><img src="/../../stuff/01db3d8fa2234583802a378998b96274.png" alt="在这里插入图片描述"><br>其中：<br><strong>CLK</strong><br>CLK 信号用于从 Host 端输出时钟信号，进行数据传输的同步和设备运作的驱动。<br>在一个时钟周期内，CMD 和 DAT0-7 信号上都可以支持传输 1 个比特，即 SDR (Single Data Rate) 模式。此外，DAT0-7 信号还支持配置为 DDR (Double Data Rate) 模式，在一个时钟周期内，可以传输 2 个比特。<br>Host 可以在通讯过程中动态调整时钟信号的频率（注，频率范围需要满足 Spec 的定义）。通过调整时钟频率，可以实现省电或者数据流控（避免 Over-run 或者 Under-run）功能。 在一些场景中，Host 端还可以关闭时钟，例如 eMMC 处于 Busy 状态时，或者接收完数据，进入 Programming State 时。<br><strong>CMD</strong><br>CMD 信号主要用于 Host 向 eMMC 发送 Command 和 eMMC 向 Host 发送对于的 Response。<br><strong>DAT0-7</strong><br>DAT0-7 信号主要用于 Host 和 eMMC 之间的数据传输。在 eMMC 上电或者软复位后，只有 DAT0 可以进行数据传输，完成初始化后，可配置 DAT0-3 或者 DAT0-7 进行数据传输，即数据总线可以配置为 4 bits 或者 8 bits 模式。<br><strong>Data Strobe</strong> （数据选通）<br>Data Strobe 时钟信号由 eMMC 发送给 Host，频率与 CLK 信号相同，<strong>用于 Host 端进行数据接收的同步</strong>。Data Strobe 信号只能在 HS400 模式下配置启用，<strong>启用后可以提高数据传输的稳定性</strong>，<strong>省去总线 tuning 过程</strong>。</p>
<blockquote>
<p>NOTE: Extended CSD byte[183] BUS_WIDTH 寄存器用于配置总线宽度和 Data Strobe</p>
</blockquote>
<h1 id="eMMC总线模型"><a href="#eMMC总线模型" class="headerlink" title="eMMC总线模型"></a>eMMC总线模型</h1><p>eMMC 总线中，可以有一个 Host，多个 eMMC Devices。总线上的所有通讯都由 Host 端以一个 Command 开始发起，Host 一次只能与一个 eMMC Device 通讯。</p>
<p>系统在上电启动后，Host 会为所有 eMMC Device 逐个分配地址（RCA，Relative device Address）。当 Host 需要和某一个 eMMC Device 通讯时，会先根据 RCA 选中该 eMMC Device，只有被选中的 eMMC Device 才会响应 Host 的 Command。</p>
<h1 id="速率模式"><a href="#速率模式" class="headerlink" title="速率模式"></a>速率模式</h1><p>随着 eMMC 协议的版本迭代，eMMC 总线的速率越来越高。为了兼容旧版本的 eMMC Device，<strong>所有 Devices 在上电启动或者 Reset 后，都会先进入兼容速率模式（Backward Compatible Mode）。在完成 eMMC Devices 的初始化后，Host 可以通过特定的流程</strong>，让 Device 进入其他高速率模式，目前支持以下的几种速率模式。<br><img src="/../../stuff/9cae3b56b99748d0a75c134ec3c4f509.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>NOTE: Extended CSD byte[185] HS_TIMING 寄存器可以配置总线速率模式 Extended CSD<br>byte[183] BUS_WIDTH 寄存器用于配置总线宽度和 Data Strobe</p>
</blockquote>
<h2 id="关键参数"><a href="#关键参数" class="headerlink" title="关键参数"></a>关键参数</h2><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>根据“组成”一节的图片中描述：<br>VCCQ is for Controller power<br>VCC is for flash power<br>即：VCC为MMC Controller&#x2F;Flash Controller的供电电压，VCCQ为Memory和Controller之间I&#x2F;O的供电。</p>
<p>一个典型硬件电路的设计：<br><img src="/../../stuff/47b106e8b90b4dad93f6939bbac6c780.png" alt="在这里插入图片描述"><br>上电初始化阶段MMC时钟频率为400KHz，需要等电压调整到它要求的VCC时（host去获取OCR中记录的电压值，上面有说），MMC时钟才会调整到更高的正常工作频率。<br>OCR寄存器描述：<br>OCR寄存器值操作条件寄存器，存储eMMC的Vccq电压配置，以及包含了状态信息bit，这个状态在eMMC上电进程结束之后被设置。<br>也即，先后过程是：上电初始化阶段MMC时钟频率为400KHz -&gt; 上电完毕 -&gt; 调整到OCR寄存器中指示的电压 -&gt; 切换到更高频率</p>
<p>对于emmc无需在运行时切换电压，而SD Card比较严格，有这个需求，所以设计时应该加入voltage ragulator。linux内核支持在dts中描述voltage ragulator，并在probe时获取并注册，在上电流程中使用-切换。<br><img src="/../../stuff/b4e03b93893c48f49090a9b2a4271b54.png" alt="在这里插入图片描述"></p>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>与SDHC控制器相关的时钟：BIU, CIU, HIU<br>BIU与CIU<br><img src="/../../stuff/c0e1669badcb4d208ff9aa615829fd7a.png" alt="在这里插入图片描述"></p>
<p><img src="/../../stuff/fa1737d6147844558956ab3ec4eba30b.png" alt="在这里插入图片描述"></p>
<p>HIU<br><img src="/../../stuff/d68bdc47e5ec4fdeb81ecac779428c44.png" alt="在这里插入图片描述"><br>可以理解为，BIU是读写寄存器和从FIFIO读数据的时钟，而CIU是控制card-specific协议的时钟，提供了时钟控制。<br>dts中应当配置这些时钟：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;sdhci0 &#123;</span><br><span class="line">	clocks = &lt;&amp;ts_clk TS_CLK_SDHC0_CCLK&gt;, &lt;&amp;ts_clk TS_CLK_SDHC0_AHB_CLK&gt;, &lt;&amp;ts_clk TS_CLK_SDHC0_SMPL_CLK&gt;;</span><br><span class="line">	clock-names = <span class="string">&quot;ciu&quot;</span>,<span class="string">&quot;hiu&quot;</span>, <span class="string">&quot;smpl_clk&quot;</span>;</span><br><span class="line">	assigned-clocks = &lt;&amp;ts_clk TS_CLK_SDHC0_CCLK&gt;;</span><br><span class="line">	assigned-clock-rates = &lt;<span class="number">200000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中smpl_clk是sample phase调节时所需要的时钟，平台相关的CLK手册里应该有实现这种时钟，probe时获取，后期tuning时需要使用它。</p>
<h1 id="DW-MCI驱动的初始化流程"><a href="#DW-MCI驱动的初始化流程" class="headerlink" title="DW_MCI驱动的初始化流程"></a>DW_MCI驱动的初始化流程</h1><p>从dw_mci_probe开始</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">dw_mci_probe</span><br><span class="line">	dw_mci_parse_dt</span><br><span class="line">		<span class="title function_">if</span> <span class="params">(!device_property_read_u32(dev, <span class="string">&quot;clock-frequency&quot;</span>, &amp;clock_frequency))</span></span><br><span class="line">		<span class="title function_">device_property_read_u32</span><span class="params">(dev, <span class="string">&quot;card-detect-delay&quot;</span>,</span></span><br><span class="line"><span class="params">						 &amp;pdata-&gt;detect_delay_ms)</span>;</span><br><span class="line">						pdata-&gt;bus_hz = clock_frequency;</span><br><span class="line">	host-&gt;hiu_clk = devm_clk_get(host-&gt;dev, <span class="string">&quot;hiu&quot;</span>);</span><br><span class="line">	host-&gt;ciu_clk = devm_clk_get(host-&gt;dev, <span class="string">&quot;ciu&quot;</span>);</span><br><span class="line">	clk_prepare_enable(host-&gt;ciu_clk);</span><br><span class="line">	<span class="keyword">if</span> (host-&gt;pdata-&gt;bus_hz) &#123;</span><br><span class="line">		ret = clk_set_rate(host-&gt;ciu_clk, host-&gt;pdata-&gt;bus_hz);</span><br><span class="line">	host-&gt;bus_hz = clk_get_rate(host-&gt;ciu_clk);</span><br><span class="line">	setup_timer(&amp;host-&gt;cmd11_timer,          <span class="comment">//专用于cmd11的执行</span></span><br><span class="line">		    dw_mci_cmd11_timer, (<span class="type">unsigned</span> <span class="type">long</span>)host);</span><br><span class="line"></span><br><span class="line">	setup_timer(&amp;host-&gt;cto_timer,</span><br><span class="line">		    dw_mci_cto_timer, (<span class="type">unsigned</span> <span class="type">long</span>)host);</span><br><span class="line"></span><br><span class="line">	setup_timer(&amp;host-&gt;dto_timer,</span><br><span class="line">		    dw_mci_dto_timer, (<span class="type">unsigned</span> <span class="type">long</span>)host);</span><br><span class="line">	INIT_LIST_HEAD(&amp;host-&gt;<span class="built_in">queue</span>);</span><br><span class="line">	tasklet_init(&amp;host-&gt;tasklet, dw_mci_tasklet_func, (<span class="type">unsigned</span> <span class="type">long</span>)host);      <span class="comment">//host-&gt;tasklet</span></span><br><span class="line">	ret = devm_request_irq(host-&gt;dev, host-&gt;irq, dw_mci_interrupt,     <span class="comment">//请求cd脚的中断</span></span><br><span class="line">			       host-&gt;irq_flags, <span class="string">&quot;dw-mci&quot;</span>, host);</span><br><span class="line">	</span><br><span class="line">	dw_mci_init_slot(host);</span><br><span class="line">		mmc_alloc_host(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dw_mci_slot), host-&gt;dev);</span><br><span class="line">			INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);      <span class="comment">//host-&gt;detect延时任务绑定到了mmc_rescan</span></span><br><span class="line">			</span><br><span class="line">			INIT_DELAYED_WORK(&amp;host-&gt;sdio_irq_work, sdio_irq_work);</span><br><span class="line">			setup_timer(&amp;host-&gt;retune_timer, mmc_retune_timer, (<span class="type">unsigned</span> <span class="type">long</span>)host);  <span class="comment">//tune定时器任务 </span></span><br><span class="line">				--&gt;该定时器任务的回调函数只是会将host-&gt;need_tune置<span class="number">1</span></span><br><span class="line">		</span><br><span class="line">		mmc-&gt;ops = &amp;dw_mci_ops;</span><br><span class="line">		mmc_regulator_get_supply(mmc);</span><br><span class="line">		mmc_of_parse(mmc);</span><br><span class="line">			<span class="comment">//初始化host-&gt;caps以及host-&gt;caps2</span></span><br><span class="line">			<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;cap-sd-highspeed&quot;</span>))</span><br><span class="line">				host-&gt;caps |= MMC_CAP_SD_HIGHSPEED;</span><br><span class="line">			<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;cap-mmc-highspeed&quot;</span>))</span><br><span class="line">				host-&gt;caps |= MMC_CAP_MMC_HIGHSPEED;</span><br><span class="line">			<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;sd-uhs-sdr12&quot;</span>))</span><br><span class="line">				host-&gt;caps |= MMC_CAP_UHS_SDR12;</span><br><span class="line">			<span class="keyword">if</span> (device_property_read_bool(dev, <span class="string">&quot;sd-uhs-sdr25&quot;</span>))</span><br><span class="line">		dw_mci_init_slot_caps(slot);</span><br><span class="line">			<span class="type">int</span> gpio_cd = mmc_gpio_get_cd(mmc);</span><br><span class="line">			present = gpio_cd;</span><br><span class="line">			<span class="keyword">return</span> present;</span><br><span class="line">				<span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mmc_host_ops</span> <span class="title">dw_mci_ops</span> =</span> &#123;</span><br><span class="line">					.get_cd			= dw_mci_get_cd,</span><br><span class="line">				&#125;</span><br><span class="line">	dw_mci_enable_cd(host);</span><br><span class="line">		<span class="keyword">if</span> (host-&gt;slot-&gt;mmc-&gt;caps &amp; MMC_CAP_NEEDS_POLL) <span class="comment">//如果需要poll模式探测，则直接退出</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		mmc_gpio_get_cd(host-&gt;slot-&gt;mmc) </span><br><span class="line">			gpiod_get_value_cansleep(ctx-&gt;cd_gpio);</span><br><span class="line">		temp = mci_readl(host, INTMASK);          <span class="comment">//打开CD中断</span></span><br><span class="line">		temp  |= SDMMC_INT_CD;</span><br><span class="line">		mci_writel(host, INTMASK, temp);</span><br><span class="line">		</span><br><span class="line">	dw_mci_interrupt</span><br><span class="line">		dw_mci_handle_cd</span><br><span class="line">			mmc_detect_change</span><br><span class="line">				_mmc_detect_change</span><br><span class="line">					<span class="title function_">mmc_schedule_delayed_work</span><span class="params">(&amp;host-&gt;detect, delay)</span>;</span><br><span class="line">queue_delayed_work(system_freezable_wq, work, delay);</span><br></pre></td></tr></table></figure>

<p>从mmc_rescan开始：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> freqs[] = &#123; <span class="number">400000</span>, <span class="number">300000</span>, <span class="number">200000</span>, <span class="number">100000</span> &#125;;</span><br><span class="line"><span class="comment">//四次尝试：</span></span><br><span class="line">mmc_rescan</span><br><span class="line">	<span class="title function_">for</span> <span class="params">(i = <span class="number">0</span>; i &lt; ARRAY_SIZE(freqs); i++)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!mmc_rescan_try_freq(host, max(freqs[i], host-&gt;f_min))) <span class="comment">//如无特别指定f_min=0</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (freqs[i] &lt;= host-&gt;f_min)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">mmc_rescan_try_freq</span><br><span class="line">	从host-&gt;caps判断MMC_CAP类型，执行相应card的attach动作</span><br><span class="line">	<span class="keyword">if</span> (host-&gt;caps &amp; MMC_CAP_NEEDS_POLL)</span><br><span class="line">		mmc_schedule_delayed_work(&amp;host-&gt;detect, HZ);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/* Order&#x27;s important: probe SDIO, then SD, then MMC */</span></span><br><span class="line">		<span class="keyword">if</span> (!(host-&gt;caps2 &amp; MMC_CAP2_NO_SDIO))</span><br><span class="line">			<span class="keyword">if</span> (!mmc_attach_sdio(host))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (!(host-&gt;caps2 &amp; MMC_CAP2_NO_SD))</span><br><span class="line">			<span class="keyword">if</span> (!mmc_attach_sd(host))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (!(host-&gt;caps2 &amp; MMC_CAP2_NO_MMC))</span><br><span class="line">			<span class="keyword">if</span> (!mmc_attach_mmc(host))   <span class="comment">//实际的MMC Card检测到attach上了</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	mmc_attach_mmc</span><br><span class="line">		<span class="title function_">mmc_attach_bus</span><span class="params">(host)</span></span><br><span class="line">			host-&gt;bus_ops = ops;</span><br><span class="line">		mmc_host_is_spi(host) <span class="comment">//看host是否是spi？</span></span><br><span class="line">			…..</span><br><span class="line">		mmc_select_voltage(host, ocr);</span><br><span class="line">			找到ocr第一个是<span class="number">1</span>的bit，其前三个bit置<span class="number">1</span></span><br><span class="line">			mmc_power_cycle <span class="comment">//下电再上电</span></span><br><span class="line">		mmc_init_card(host, rocr, <span class="literal">NULL</span>);  <span class="comment">//older == NULL 探测并初始化卡</span></span><br><span class="line">			mmc_send_cid(host, cid);</span><br><span class="line">			card = mmc_alloc_card(host, &amp;mmc_type);</span><br><span class="line">			card-&gt;ocr = ocr;</span><br><span class="line">			card-&gt;type = MMC_TYPE_MMC;</span><br><span class="line">			card-&gt;rca = <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">memcpy</span>(card-&gt;raw_cid, cid, <span class="keyword">sizeof</span>(card-&gt;raw_cid));</span><br><span class="line">			mmc_send_csd(card, card-&gt;raw_csd);</span><br><span class="line">			mmc_decode_csd(card); <span class="comment">//Card-Specific Data register</span></span><br><span class="line">				mmc_send_cxd_native(card-&gt;host, card-&gt;rca &lt;&lt; <span class="number">16</span>,	csd,</span><br><span class="line">							MMC_SEND_CSD);</span><br><span class="line">					cmd.opcode = opcode;  <span class="comment">//填充cmd结构，实际读写host寄存器了</span></span><br><span class="line">					cmd.arg = arg;</span><br><span class="line">					cmd.flags = MMC_RSP_R2 | MMC_CMD_AC;</span><br><span class="line">					mmc_wait_for_cmd(host, &amp;cmd, MMC_CMD_RETRIES);</span><br><span class="line">						<span class="class"><span class="keyword">struct</span> <span class="title">mmc_request</span> <span class="title">mrq</span> =</span> &#123;&#125;;</span><br><span class="line">						mmc_wait_for_req(host, &amp;mrq);</span><br><span class="line">							__mmc_start_req</span><br><span class="line">								<span class="comment">//使用了completion信号量</span></span><br><span class="line">								init_completion(&amp;mrq-&gt;completion);</span><br><span class="line">								mrq-&gt;done = mmc_wait_done;</span><br><span class="line">								init_completion(&amp;mrq-&gt;cmd_completion);</span><br><span class="line">								</span><br><span class="line">								mmc_start_request(host, mrq);</span><br><span class="line">									__mmc_start_request</span><br><span class="line">										<span class="title function_">mmc_retune</span><span class="params">(host)</span>;  <span class="comment">//判断host-&gt;need_tune值以确定是否需要tune</span></span><br><span class="line">										mmc_request_done</span><br><span class="line">											mmc_complete_cmd</span><br><span class="line">												<span class="title function_">completion_done</span><span class="params">(&amp;mrq-&gt;cmd_completion)</span></span><br><span class="line">			<span class="title function_">mmc_decode_cid</span><span class="params">(card)</span>;   <span class="comment">//cid主要是一些identity相关的信息</span></span><br><span class="line">				根据card-&gt;csd.mmca_vsn，设置其他mmc_card的字段</span><br><span class="line">					card-&gt;cid.manfid	= UNSTUFF_BITS(resp, <span class="number">104</span>, <span class="number">24</span>);</span><br><span class="line">					card-&gt;cid.prod_name[<span class="number">0</span>]	= UNSTUFF_BITS(resp, <span class="number">96</span>, <span class="number">8</span>);</span><br><span class="line">					card-&gt;cid.prod_name[<span class="number">1</span>]	= UNSTUFF_BITS(resp, <span class="number">88</span>, <span class="number">8</span>);</span><br><span class="line">			mmc_read_ext_csd(card)  <span class="comment">//ext_csd，额外的csd信息</span></span><br><span class="line">				mmc_get_ext_csd(card, &amp;ext_csd);</span><br><span class="line">				mmc_decode_ext_csd(card, ext_csd);</span><br><span class="line">				      通过ext_csd数组对card-&gt;ext_csd结构成员的初始化</span><br><span class="line">				mmc_select_card_type：</span><br><span class="line">				      通过判断host-&gt;caps与host-&gt;caps2，设置avail_type以及hs_max_dtr</span><br><span class="line">					………</span><br><span class="line">					<span class="keyword">if</span> (caps2 &amp; MMC_CAP2_HS200_1_8V_SDR &amp;&amp;</span><br><span class="line">					    card_type &amp; EXT_CSD_CARD_TYPE_HS200_1_8V) &#123;</span><br><span class="line">						hs200_max_dtr = MMC_HS200_MAX_DTR;</span><br><span class="line">						avail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V;</span><br><span class="line">					&#125;</span><br><span class="line">				</span><br><span class="line">					<span class="keyword">if</span> (caps2 &amp; MMC_CAP2_HS200_1_2V_SDR &amp;&amp;</span><br><span class="line">					    card_type &amp; EXT_CSD_CARD_TYPE_HS200_1_2V) &#123;</span><br><span class="line">						hs200_max_dtr = MMC_HS200_MAX_DTR;</span><br><span class="line">						avail_type |= EXT_CSD_CARD_TYPE_HS200_1_2V;</span><br><span class="line">					&#125;</span><br><span class="line">					…………</span><br><span class="line">					card-&gt;ext_csd.hs_max_dtr = hs_max_dtr;</span><br><span class="line">					card-&gt;ext_csd.hs200_max_dtr = hs200_max_dtr;</span><br><span class="line">					card-&gt;mmc_avail_type = avail_type;</span><br><span class="line">					</span><br><span class="line">			err = mmc_select_timing(card);</span><br><span class="line">				<span class="comment">//通过判断mmc_avail_type支持哪些模式，去初始化各个模式下的timing </span></span><br><span class="line">				<span class="keyword">if</span> (card-&gt;mmc_avail_type &amp; EXT_CSD_CARD_TYPE_HS400ES)</span><br><span class="line">					err = mmc_select_hs400es(card);</span><br><span class="line">						<span class="comment">//修改ext_csd寄存器</span></span><br><span class="line">						--&gt;__mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,</span><br><span class="line">									   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,</span><br><span class="line">									   card-&gt;ext_csd.generic_cmd6_time, MMC_TIMING_MMC_HS,</span><br><span class="line">									   <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">							--&gt; mmc_wait_for_cmd</span><br><span class="line">							--&gt;mmc_poll_for_busy</span><br><span class="line">							--&gt;mmc_set_timing</span><br><span class="line">								</span><br><span class="line">					<span class="keyword">else</span> <span class="title function_">if</span> <span class="params">(card-&gt;mmc_avail_type &amp; EXT_CSD_CARD_TYPE_HS200)</span></span><br><span class="line">						err = mmc_select_hs200(card);</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> (card-&gt;mmc_avail_type &amp; EXT_CSD_CARD_TYPE_HS)</span><br><span class="line">						err = mmc_select_hs(card);</span><br><span class="line">					哪里初始化了card-&gt;mmc_avail_type？</span><br><span class="line">	</span><br><span class="line">			<span class="keyword">if</span> (mmc_card_hs200(card)) &#123;</span><br><span class="line">				err = mmc_hs200_tuning(card); <span class="comment">//hs200需要tunning 看另一章节的调用解释</span></span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">goto</span> free_card;</span><br><span class="line">		</span><br><span class="line">				err = mmc_select_hs400(card);</span><br><span class="line">				<span class="keyword">if</span> (err)</span><br><span class="line">					<span class="keyword">goto</span> free_card;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mmc_card_hs400es(card)) &#123;</span><br><span class="line">				<span class="comment">/* Select the desired bus width optionally */</span></span><br><span class="line">				err = mmc_select_bus_width(card);</span><br><span class="line">				<span class="keyword">if</span> (err &gt; <span class="number">0</span> &amp;&amp; mmc_card_hs(card)) &#123;</span><br><span class="line">					err = mmc_select_hs_ddr(card);</span><br><span class="line">					<span class="keyword">if</span> (err)</span><br><span class="line">						<span class="keyword">goto</span> free_card;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="DW-MCI-如何配置不同mmc模式"><a href="#DW-MCI-如何配置不同mmc模式" class="headerlink" title="DW_MCI 如何配置不同mmc模式"></a>DW_MCI 如何配置不同mmc模式</h1><p>根据上面的初始化过程, 不难看出，最终调用哪个<strong>mmc_select_xxx</strong>来切换哪种模式，取决于card-&gt;mmc_avail_type，而card-&gt;mmc_avail_type是在mmc_select_card_type接口中，根据host-&gt;caps，host-&gt;caps2以及<strong>card-&gt;ext_csd.raw_card_type</strong>来决定的。<br>其中，host-&gt;caps，host-&gt;caps2来自对dts的parse，mmc_of_parse接口。而card-&gt;ext_csd.raw_card_type，则来自mmc_read_ext_csd(card)  &#x2F;&#x2F;ext_csd，额外的csd信息 –&gt; mmc_get_ext_csd(card, &amp;ext_csd); –&gt; mmc_decode_ext_csd(card, ext_csd);这个过程，从mmc中读取ext_csd字段到内存中，然后decode解码到host的ext_csd成员的各个域中。<br>因此，配置mmc的模式，是由dts的配置，以及mmc卡本身特性，即ext_csd中的内容决定的。<br>在dw_mci控制器驱动下，以三星的KLM8G1GETF-B041为例：<br><img src="/../../stuff/3f6cf2f283a046ebb5d141ccf96b30c2.png" alt="在这里插入图片描述"><br>由其datasheet中，DEVICE_TYPE[196]的描述可以看到这款emmc所支持的所有模式。</p>
<p>默认配置下，mmc跑在sdr 25M下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;sdhci0 &#123;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果要配置sdr 52M，则使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;sdhci0 &#123;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    cap-mmc-highspeed;     <span class="comment">//for SDR 52M</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果要配置为sdr 200M，则使用:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;sdhci0 &#123;</span><br><span class="line">	status = <span class="string">&quot;okay&quot;</span>;</span><br><span class="line">    mmc-hs200<span class="number">-1</span>_8v;          <span class="comment">//for hs200 200M</span></span><br><span class="line">    pinctrl-names = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    pinctrl<span class="number">-0</span> = &lt;&amp;emmc0_pinctrl&gt;;</span><br><span class="line">    ts,<span class="keyword">default</span>-sample-phase = &lt;<span class="number">0</span>&gt;;</span><br><span class="line">    ts,desired-num-phases = &lt;<span class="number">360</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sdr200模式，需要执行tune。如果tuning接口没有实现，启动时会报错，以下是mmc_hs200_tunning的调用过程：<br><img src="/../../stuff/16bb965442834c298980dee21e1cdf2b.png" alt="在这里插入图片描述"></p>
<h1 id="DW-MCI驱动-tune过程"><a href="#DW-MCI驱动-tune过程" class="headerlink" title="DW_MCI驱动 tune过程"></a>DW_MCI驱动 tune过程</h1><p>Sampling Tuning 是用于计算 Host 最佳采样时间点的流程，大致的流程如下：</p>
<ol>
<li>Host 将采样时间点重置为默认值</li>
<li>Host 向 eMMC Device 发送 Send Tuning Block 命令</li>
<li>eMMC Device 向 Host 发送固定的 Tuning Block 数据</li>
<li>Host 接收到 Tuning Block 并进行校验</li>
<li>Host 修改采样时点，重新从第 2 步开始执行，直到 Host 获取到一个有效采样时间点区间</li>
<li>Host 取有效采样时间点区间的中间值作为采样时间点，并推出 Tuning 流程</li>
</ol>
<p>在dw mobile storage host databook里关于tuning的描述:<br><img src="/../../stuff/565984fdec74475f8e7497d9fc0f8b73.png" alt="在这里插入图片描述"><br>对于SDR104和HS200模式，来自最大输出延迟card可以达到2UI(这里的UI是一个CIU时钟周期)，为了采样数据的正确，采样点必须使用tuning来寻找。固件必须使用tuning信息，去调节cclk_in和cclk_in_sample之间的延迟。延迟可以使用phase shifter来实现，最小的phase-shift精度为90°. phase_shift输入必须基于tuning，由host controller应用提供<br>note里说，建议使用最小22.5°的phase-shift精度，更精确，更好。。（咱就是说，上下文能否不要啪啪打脸）</p>
<p><img src="/../../stuff/ed61d4b25ced4fd1b4de4608084ea102.png" alt="在这里插入图片描述"><br>tuning commands 和 tuning data<br><img src="/../../stuff/22927a7b815140e6b5478a3aa28b4ae4.png" alt="在这里插入图片描述"><br><img src="/../../stuff/7c8281c83c5f4bb3bb28660a0e573c1d.png" alt="在这里插入图片描述"><br>手册里给出了更详细的tunning描述，如何调节采样点？这应该和各个平台的实现不同，一个寄存器demo：<br><img src="/../../stuff/ebf3d4221bd94e1792ca39da1305e9b5.png" alt="在这里插入图片描述"></p>
<p>这里给出一个tuning的时序图：<br><img src="/../../stuff/4236210ed6424bf98ebe9e238cf72d75.png" alt="在这里插入图片描述"><br>此处sd_cclk_smpl的移位，由sd_cclk_smpl_ph决定，sd_cclk_smpl_ph的值由上面展示的寄存器的值决定。sd_cclk_smpl每加一，sd_cclk_phase的波形偏移一个pll0的时钟周期(就是图中sd_cclk_src的一个周期，它来自PLL0)。其note注释中提到，sd_cclk_smpl取值不能大于sd_cclk分频系数。如果sd_cclk分频系数给的很小，那么cclk_smpl寄存器可选的值就更小，tune精度就更小。（我理解，如果cclk_smple上限为10，那么tune精度就是360&#x2F;10 &#x3D; 36°)</p>
<p>需要了解的是，tuning block data：<br>Tuning Block 是专门为了 Tuning 而设计的一组特殊数据。相对于普通的数据，这组特殊数据在传输过程中，会更高概率的出现 high SSO noise、deterministic jitter、ISI、timing errors 等问题。这组数据的具体内容如下所示：<br><img src="/../../stuff/532c911acf5f40e8b000cb9dbe1046f8.png" alt="在这里插入图片描述"><br><img src="/../../stuff/e3b279e8189d4ddab70dce91b227f2b9.png" alt="在这里插入图片描述"></p>
<h2 id="实际的tune实现"><a href="#实际的tune实现" class="headerlink" title="实际的tune实现"></a>实际的tune实现</h2><p>根据前面mmc_hs200_tunning的调用过程，我们需要实现execute_tuning接口：<br><img src="/../../stuff/c434d366014a4c8da41d5ec52bfb4b7a.png" alt="在这里插入图片描述"><br>这个接口里，需要调用dw_mci_drv_data私有数据结构里提供的tunning接口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dw_mci_execute_tuning</span><span class="params">(<span class="keyword">struct</span> mmc_host *mmc, u32 opcode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dw_mci_slot</span> *<span class="title">slot</span> =</span> mmc_priv(mmc);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dw_mci</span> *<span class="title">host</span> =</span> slot-&gt;host;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dw_mci_drv_data</span> *<span class="title">drv_data</span> =</span> host-&gt;drv_data;</span><br><span class="line">    </span><br><span class="line">	<span class="type">int</span> err = -EINVAL;</span><br><span class="line">	<span class="keyword">if</span> (drv_data &amp;&amp; drv_data-&gt;execute_tuning)</span><br><span class="line">		err = drv_data-&gt;execute_tuning(slot, opcode);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该结构会在probe时获取相应data成员，并进行注册<br><img src="/../../stuff/0db080155a594dba99230de617a98254.png" alt="在这里插入图片描述"><br>这里移植了RK的tuning过程，适配到我自己的平台上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dw_mci_XXXXX_execute_tuning</span><span class="params">(<span class="keyword">struct</span> dw_mci_slot *slot, u32 opcode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TS_SDHC_EMMC_RUN_HS200</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dw_mci</span> *<span class="title">host</span> =</span> slot-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dw_mci_ts_priv_data</span> *<span class="title">priv</span> =</span> host-&gt;priv;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mmc_host</span> *<span class="title">mmc</span> =</span> slot-&gt;mmc;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> sample_clk_rate, parent_of_sample_rate;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">bool</span> v, prev_v = <span class="number">0</span>, first_v;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">range_t</span> &#123;</span></span><br><span class="line">		<span class="type">int</span> start;</span><br><span class="line">		<span class="type">int</span> end; <span class="comment">/* inclusive */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">range_t</span> *<span class="title">ranges</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> range_count = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> longest_range_len = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> longest_range = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> middle_phase;</span><br><span class="line"></span><br><span class="line">    parent_of_sample_rate = (<span class="number">2000000000UL</span>); <span class="comment">//temp, not elegent</span></span><br><span class="line">    sample_clk_rate = clk_get_rate(priv-&gt;sample_clk);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(priv-&gt;sample_clk)) &#123;</span><br><span class="line">		dev_err(host-&gt;dev, <span class="string">&quot;Tuning clock (sample_clk) not defined.\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EIO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ranges = kmalloc_array(priv-&gt;num_phases / <span class="number">2</span> + <span class="number">1</span>,</span><br><span class="line">			       <span class="keyword">sizeof</span>(*ranges), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ranges)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Try each phase and extract good ranges */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; priv-&gt;num_phases; ) &#123;</span><br><span class="line">		clk_set_phase(priv-&gt;sample_clk,</span><br><span class="line">			      TUNING_ITERATION_TO_PHASE(i, priv-&gt;num_phases));</span><br><span class="line"></span><br><span class="line">		v = !mmc_send_tuning(mmc, opcode, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">			first_v = v;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((!prev_v) &amp;&amp; v) &#123;</span><br><span class="line">			range_count++;</span><br><span class="line">			ranges[range_count<span class="number">-1</span>].start = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (v) &#123;</span><br><span class="line">			ranges[range_count<span class="number">-1</span>].end = i;</span><br><span class="line">			i++;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == priv-&gt;num_phases - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">/* No extra skipping rules if we&#x27;re at the end */</span></span><br><span class="line">			i++;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * No need to check too close to an invalid</span></span><br><span class="line"><span class="comment">			 * one since testing bad phases is slow.  Skip</span></span><br><span class="line"><span class="comment">			 * 20 degrees.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">             pr_debug(<span class="string">&quot;parent_of_sample_rate / sample_clk_rate:%d\n&quot;</span>, parent_of_sample_rate / sample_clk_rate);</span><br><span class="line">			i += DIV_ROUND_UP((parent_of_sample_rate / sample_clk_rate) * priv-&gt;num_phases, <span class="number">360</span>);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Always test the last one */</span></span><br><span class="line">			<span class="keyword">if</span> (i &gt;= priv-&gt;num_phases)</span><br><span class="line">				i = priv-&gt;num_phases - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		prev_v = v;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (range_count == <span class="number">0</span>) &#123;</span><br><span class="line">		dev_warn(host-&gt;dev, <span class="string">&quot;All phases bad!&quot;</span>);</span><br><span class="line">		ret = -EIO;</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* wrap around case, merge the end points */</span></span><br><span class="line">	<span class="keyword">if</span> ((range_count &gt; <span class="number">1</span>) &amp;&amp; first_v &amp;&amp; v) &#123;</span><br><span class="line">		ranges[<span class="number">0</span>].start = ranges[range_count<span class="number">-1</span>].start;</span><br><span class="line">		range_count--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ranges[<span class="number">0</span>].start == <span class="number">0</span> &amp;&amp; ranges[<span class="number">0</span>].end == priv-&gt;num_phases - <span class="number">1</span>) &#123;</span><br><span class="line">		clk_set_phase(priv-&gt;sample_clk, priv-&gt;default_sample_phase);</span><br><span class="line">		dev_info(host-&gt;dev, <span class="string">&quot;All phases work, using default phase %d.&quot;</span>,</span><br><span class="line">			 priv-&gt;default_sample_phase);</span><br><span class="line">		<span class="keyword">goto</span> <span class="built_in">free</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Find the longest range */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; range_count; i++) &#123;</span><br><span class="line">		<span class="type">int</span> len = (ranges[i].end - ranges[i].start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">			len += priv-&gt;num_phases;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (longest_range_len &lt; len) &#123;</span><br><span class="line">			longest_range_len = len;</span><br><span class="line">			longest_range = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		dev_dbg(host-&gt;dev, <span class="string">&quot;Good phase range %d-%d (%d len)\n&quot;</span>,</span><br><span class="line">			TUNING_ITERATION_TO_PHASE(ranges[i].start,</span><br><span class="line">						  priv-&gt;num_phases),</span><br><span class="line">			TUNING_ITERATION_TO_PHASE(ranges[i].end,</span><br><span class="line">						  priv-&gt;num_phases),</span><br><span class="line">			len</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dev_dbg(host-&gt;dev, <span class="string">&quot;Best phase range %d-%d (%d len)\n&quot;</span>,</span><br><span class="line">		TUNING_ITERATION_TO_PHASE(ranges[longest_range].start,</span><br><span class="line">					  priv-&gt;num_phases),</span><br><span class="line">		TUNING_ITERATION_TO_PHASE(ranges[longest_range].end,</span><br><span class="line">					  priv-&gt;num_phases),</span><br><span class="line">		longest_range_len</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">	middle_phase = ranges[longest_range].start + longest_range_len / <span class="number">2</span>;</span><br><span class="line">	middle_phase %= priv-&gt;num_phases;</span><br><span class="line">	dev_info(host-&gt;dev, <span class="string">&quot;Successfully tuned phase to %d\n&quot;</span>,</span><br><span class="line">		 TUNING_ITERATION_TO_PHASE(middle_phase, priv-&gt;num_phases));</span><br><span class="line"></span><br><span class="line">	clk_set_phase(priv-&gt;sample_clk,</span><br><span class="line">		      TUNING_ITERATION_TO_PHASE(middle_phase,</span><br><span class="line">						priv-&gt;num_phases));</span><br><span class="line"><span class="built_in">free</span>:</span><br><span class="line">	kfree(ranges);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法会编译所有采样点，通过clk_get_rate去调节sample_clk，往mmc发送tuning block data并进行校验，找到一个最长的可用采样点的分区，以其中间值来设置最终的sample_clk寄存器。</p>
<p>主要注意一下<code>clk_get_rate(priv-&gt;sample_clk);</code>接口，该接口需要CCF框架的支持，对CCF框架的理解可以阅读我<a target="_blank" rel="noopener" href="https://editor.csdn.net/md/?articleId=130751112">另一篇博客：</a><br>该接口最后就是要根据tunning流中传下来的degrees，计算出一个phase值，写入上面的sample_ph寄存器。<br>该接口的实现：<br><img src="/../../stuff/9a006ab49fe6469ea3c72e4ada6ec570.png" alt="在这里插入图片描述"></p>
<h1 id="DW-MCI驱动-如何发送命令与数据"><a href="#DW-MCI驱动-如何发送命令与数据" class="headerlink" title="DW_MCI驱动 如何发送命令与数据"></a>DW_MCI驱动 如何发送命令与数据</h1><p>TODO:</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/10/24/sdio/sdio_smpl_ph_vs_drv_ph/" rel="prev" title="SDIO MSHC 采样相位与驱动相位">
                  <i class="fa fa-angle-left"></i> SDIO MSHC 采样相位与驱动相位
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/24/dma/dma_basic_knowledge/" rel="next" title="DMA Basic Knowledge">
                  DMA Basic Knowledge <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Luyuan</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
<!--
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a>
  </div> -->



    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
